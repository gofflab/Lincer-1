#!/usr/bin/env python

import sys
try:
    sample_sheet = sys.argv[1]
    ref_gtf = sys.argv[2]
except IndexError:
    print 'Usage: %s SAMPLE_SHEET REFERENCE_GTF' % sys.argv[0]
    sys.exit(1)

import pandas as pd
import subprocess
import shutil
import os
from glob import glob

def main(sample_sheet, ref_gtf):
    #
    # 1. Find novel transcripts from each sample.
    #
    print >> sys.stderr, 'Loading sample sheet.'
    print >> sys.stderr, '  src: %s' % sample_sheet
    samples = pd.read_table(sample_sheet, header=None, index_col=0, names=['gtf_path'])
    samples.index.name = 'sample'
    samples['gtf_out'] = samples.index + '.novel.gtf'
    
    for sample, gtf, gtf_out in samples.itertuples():
        print >> sys.stderr, 'Processing:', sample
        find_novel_transcripts(sample, gtf, ref_gtf, gtf_out)
        print >> sys.stderr, '  Summary: %s.summary.tsv' % sample
        print >> sys.stderr, '  GTF Out: %s.novel.gtf' % sample
    
    #
    # 2. Merge novel transcripts into a single GTF.
    #
    samples[['gtf_out']].to_csv('novel_linc_candidate_gtfs.txt', header=None, index=None)
    subprocess.check_call('cuffmerge novel_linc_candidate_gtfs.txt', shell=True)
    shutil.move('merged_asm/merged.gtf', 'novel_linc_candidates.gtf')
    shutil.rmtree('merged_asm')
    os.remove('novel_linc_candidate_gtfs.txt')

def find_novel_transcripts(sample, gtf, ref_gtf, gtf_out):
    '''
    Find all novel, long, well-covered, multi-exonic transcripts
    from de novo transcript assemblies generated by Cufflinks.
    '''

    # Symlink the input GTF to the current working directory,
    # or cufflinks will put its output somewhere inconvenient.
    gtf_local = sample + '.gtf'
    if not os.path.exists(gtf_local):
        os.symlink(gtf, gtf_local)

    #
    # Run cuffcompare against reference transcriptome.
    #
    cmd = 'cuffcompare -r %s %s' % (ref_gtf, gtf_local)
    subprocess.check_call(cmd,
                          shell=True,
                          stdout=open('cuffcmp.stdout', 'w'),
                          stderr=open('cuffcmp.stderr', 'w'))

    #
    # Extract information from tmap file.
    #
    t_overlap = pd.read_table('cuffcmp.%s.tmap' % gtf_local, usecols=[2, 4], index_col=1)
    t_overlap.index.name = 'transcript_id'
    for junk_file in glob('cuffcmp.*'):
        os.remove(junk_file)

    #
    # Load relevant GTF columns as a table.
    #
    x = pd.read_table(gtf_local, header=None, usecols=[2, 3, 4, 8])
    x.columns = ['feature', 'start', 'end', 'attrs']
    x = x[x.feature == 'exon']

    #
    # Extract relevant features from attrs column.
    #
    x['gene_id'] = x.attrs.str.split('gene_id').str[1].str.split('"').str[1]
    x['transcript_id'] = x.attrs.str.split('transcript_id').str[1].str.split('"').str[1]
    x['length'] = x.end - x.start + 1
    x['exons'] = 1
    x['coverage'] = x.attrs.str.split('cov').str[1].str.split('"').str[1].astype(float)

    x = x[['gene_id', 'transcript_id', 'length', 'exons', 'coverage']]

    t_length = x.groupby('transcript_id')[['length']].sum()
    t_num_exons = x.groupby('transcript_id')[['exons']].sum()
    t_coverage = x.groupby('transcript_id')[['coverage']].first()

    #
    # Generate table summarizing all filter criteria.
    #
    y = t_length.join(t_num_exons).join(t_coverage).join(t_overlap)
    y.to_csv(sample + '.summary.tsv', sep='\t')

    #
    # Apply filters to table.
    #
    z = y[
        (y.length >= 200)
        & (y.exons > 1)
        & (y.coverage >= 3.0)
        & (y.class_code.isin(['u', 'j', 'i', 'x']))
    ]

    #
    # Generate a filtered GTF.
    #
    filter_gtf_by_transcript(gtf_local, gtf_out, z.index)

def filter_gtf_by_transcript(gtf_in, gtf_out, transcripts_to_keep):

    outfid = open(gtf_out, 'w')
    infid = open(gtf_in, 'r')
    
    for line in infid:

        # Skip empty lines and comments.
        if len(line) == 0 or line[0] == '#':
            continue

        # Extract transcript_id.
        row = line.split()
        transcript_id = row[11].split('"')[1]

        # Write selected lines to output GTF.
        if transcript_id in transcripts_to_keep:
            outfid.write(line)

    infid.close()
    outfid.close()

if __name__ == '__main__':
    main(sample_sheet, ref_gtf)
